diff --git src://.devcontainer/devcontainer.json dst://.devcontainer/devcontainer.json
new file mode 100644
index 00000000..334158be
--- /dev/null
+++ dst://.devcontainer/devcontainer.json
@@ -0,0 +1,13 @@
+{
+  "name": "openvsx-devcontainer",
+  "image": "mcr.microsoft.com/devcontainers/base:ubuntu",
+  "features": {
+    "ghcr.io/devcontainers/features/java:1": {
+      "version": "21",
+      "installGradle": true
+    },
+    "ghcr.io/devcontainers/features/node:1": {},
+    "ghcr.io/devcontainers/features/docker-in-docker:2": {},
+    "ghcr.io/devcontainers/features/git:1": {}
+  }
+}
diff --git src://.github/workflows/main.yml dst://.github/workflows/main.yml
index f7d69aff..e6bbb10c 100644
--- src://.github/workflows/main.yml
+++ dst://.github/workflows/main.yml
@@ -2,22 +2,22 @@ name: CI
 
 on:
   push:
     branches:
       - master
   pull_request:
     branches:
       - master
 
 env:
-  SERVER_TAG: ghcr.io/eclipse/openvsx-server
-  WEBUI_TAG: ghcr.io/eclipse/openvsx-webui
+  SERVER_TAG: ghcr.io/teknolojikpanda/openvsx-server
+  WEBUI_TAG: ghcr.io/teknolojikpanda/openvsx-webui
 
 jobs:
   build:
     permissions:
       contents: none
     runs-on: ubuntu-latest
     steps:
     - name: Set up Node.js
       uses: actions/setup-node@v4
       with:
@@ -39,31 +39,27 @@ jobs:
     - name: Build Web UI Image
       run: docker build -t $WEBUI_TAG:$IMAGE_VERSION webui
     - name: Get all changed server files
       id: changed_server_files
       uses: tj-actions/changed-files@v46.0.5
       with:
         files: server/**
     - name: Run Server Tests
       if: steps.changed_server_files.outputs.any_changed == 'true'
       run: server/gradlew --no-daemon -p server check
-      env:
-        DEVELOCITY_ACCESS_KEY: ${{ secrets.DEVELOCITY_API_TOKEN }}
     - name: Build Server Image
-      run: docker build -t $SERVER_TAG:$IMAGE_VERSION server --secret id=dv-key,env=DEVELOCITY_ACCESS_KEY
-      env:
-        DEVELOCITY_ACCESS_KEY: ${{ secrets.DEVELOCITY_API_TOKEN }}
+      run: docker build -t $SERVER_TAG:$IMAGE_VERSION server
     - name: Push Docker Images
       run: |
         echo ${{ secrets.BOT_ACCESS_TOKEN }} | docker login ghcr.io -u $GITHUB_ACTOR --password-stdin
         docker push $SERVER_TAG:$IMAGE_VERSION
         docker push $WEBUI_TAG:$IMAGE_VERSION
-      if: github.repository == 'eclipse/openvsx' && github.ref == 'refs/heads/master'
+      if: github.repository == 'teknolojikpanda/openvsx' && github.ref == 'refs/heads/master'
     - name: Save PR number to file
       if: github.event_name == 'pull_request'
       run: echo ${{ github.event.number }} > PR_NUMBER.txt
     - name: Archive PR number
       if: github.event_name == 'pull_request'
       uses: actions/upload-artifact@v4
       with:
         name: PR_NUMBER
         path: PR_NUMBER.txt
diff --git src://.github/workflows/release.yml dst://.github/workflows/release.yml
index ef51702d..733d71bb 100644
--- src://.github/workflows/release.yml
+++ dst://.github/workflows/release.yml
@@ -1,30 +1,61 @@
 name: Release
 
 on:
   release:
     types: [published]
 
 env:
-  SERVER_TAG: ghcr.io/eclipse/openvsx-server
-  WEBUI_TAG: ghcr.io/eclipse/openvsx-webui
+  SERVER_TAG: ghcr.io/teknolojikpanda/openvsx-server
+  WEBUI_TAG: ghcr.io/teknolojikpanda/openvsx-webui
+  REGISTRY: ghcr.io
 
 jobs:
   build:
     permissions:
-      contents: none
+      contents: read
+      packages: write
+      attestations: write
+      id-token: write
+      
     runs-on: ubuntu-latest
+    
     steps:
-    - uses: actions/checkout@v2
-    - name: Set Image Version
-      run: echo "IMAGE_VERSION=${{ github.event.release.tag_name }}" >> $GITHUB_ENV
-    - name: Build Web UI Image
-      run: docker build -t $WEBUI_TAG:$IMAGE_VERSION webui
-    - name: Build Server Image
-      run: docker build -t $SERVER_TAG:$IMAGE_VERSION server --secret id=dv-key,env=DEVELOCITY_ACCESS_KEY
-      env:
-        DEVELOCITY_ACCESS_KEY: ${{ secrets.DEVELOCITY_API_TOKEN }}
-    - name: Push Docker Images
-      run: |
-        echo ${{ secrets.BOT_ACCESS_TOKEN }} | docker login ghcr.io -u $GITHUB_ACTOR --password-stdin
-        docker push $SERVER_TAG:$IMAGE_VERSION
-        docker push $WEBUI_TAG:$IMAGE_VERSION
+    - name: Checkout repository
+      uses: actions/checkout@v5
+      
+    - name: Log in to the Container registry
+      uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
+      with:
+        registry: ${{ env.REGISTRY }}
+        username: ${{ github.actor }}
+        password: ${{ secrets.BOT_ACCESS_TOKEN }}
+        
+    - name: Build and push Docker image - WEBUI
+      id: webui-push
+      uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
+      with:
+        context: webui
+        push: true
+        tags: ${{ env.WEBUI_TAG }}:${{ github.event.release.tag_name }}
+        
+    - name: Build and push Docker image - SERVER
+      id: server-push
+      uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
+      with:
+        context: server
+        push: true
+        tags: ${{ env.SERVER_TAG }}:${{ github.event.release.tag_name }}
+        
+    - name: Server Generate artifact attestation
+      uses: actions/attest-build-provenance@v3
+      with:
+        subject-name: ${{ env.REGISTRY }}/${{ env.SERVER_TAG }}
+        subject-digest: ${{ steps.server-push.outputs.digest }}
+        push-to-registry: true
+        
+    - name: Web UI Generate artifact attestation
+      uses: actions/attest-build-provenance@v3
+      with:
+        subject-name: ${{ env.REGISTRY }}/${{ env.WEBUI_TAG }}
+        subject-digest: ${{ steps.webui-push.outputs.digest }}
+        push-to-registry: true
diff --git src://.vscode/settings.json dst://.vscode/settings.json
index 251001f9..463f3b87 100644
--- src://.vscode/settings.json
+++ dst://.vscode/settings.json
@@ -6,12 +6,13 @@
     },
     "eslint.packageManager": "yarn",
     "java.dependency.syncWithFolderExplorer": true,
     "java.format.enabled": false,
     "gradle.nestedProjects": true,
     "gradle.javaDebug": {
         "tasks": [
             "runServer"
         ]
     },
-    "java.saveActions.organizeImports": true
+    "java.saveActions.organizeImports": true,
+    "java.compile.nullAnalysis.mode": "automatic"
 }
\ No newline at end of file
diff --git src://deploy/docker/Dockerfile dst://deploy/docker/Dockerfile
index 1916d0d6..2e03c431 100644
--- src://deploy/docker/Dockerfile
+++ dst://deploy/docker/Dockerfile
@@ -16,26 +16,26 @@ RUN apt-get update \
   && rm -rf /var/lib/apt/lists/* \
   && curl -sSL https://deb.nodesource.com/setup_20.x | bash - \
   && apt-get install -y nodejs \
   && apt-get clean \
   && corepack enable \
   && corepack prepare yarn@stable --activate
 
 ARG OPENVSX_VERSION
 ENV VERSION=$OPENVSX_VERSION
 
-RUN git clone --branch ${VERSION} --depth 1 https://github.com/eclipse/openvsx.git /workdir
+RUN git clone --branch ${VERSION} --depth 1 https://github.com/teknolojikpanda/openvsx.git /workdir
 COPY ./configuration /workdir/configuration
 
 RUN /usr/bin/yarn --cwd webui \
   && /usr/bin/yarn --cwd webui build \
   && /usr/bin/yarn --cwd webui build:default
 
 
 # Main image derived from openvsx-server
-FROM ghcr.io/eclipse/openvsx-server:${OPENVSX_VERSION}
+FROM ghcr.io/teknolojikpanda/openvsx-server:${OPENVSX_VERSION}
 ARG OPENVSX_VERSION
 
 COPY --from=builder --chown=openvsx:openvsx /workdir/webui/static/ BOOT-INF/classes/static/
 COPY --from=builder --chown=openvsx:openvsx /workdir/configuration/application.yml config/
 
 RUN sed -i "s/<OPENVSX_VERSION>/$OPENVSX_VERSION/g" config/application.yml
\ No newline at end of file
diff --git src://deploy/docker/build.sh dst://deploy/docker/build.sh
old mode 100644
new mode 100755
index 15b95385..82a01a69
--- src://deploy/docker/build.sh
+++ dst://deploy/docker/build.sh
@@ -1,4 +1,4 @@
 #/bin/bash
 
-export OPENVSX_VERSION=`curl -sSL https://api.github.com/repos/eclipse/openvsx/releases/latest | jq -r ".tag_name"`
-sudo docker build -t "openvsx:$OPENVSX_VERSION" --build-arg "OPENVSX_VERSION=$OPENVSX_VERSION" .
\ No newline at end of file
+export OPENVSX_VERSION=`curl -sSL https://api.github.com/repos/teknolojikpanda/openvsx/releases/latest | jq -r ".tag_name"`
+docker buildx build -t "teknolojikpanda/openvsx:$OPENVSX_VERSION" --build-arg "OPENVSX_VERSION=$OPENVSX_VERSION" .
diff --git src://deploy/docker/configuration/application.yml dst://deploy/docker/configuration/application.yml
index 46124a4f..5b2e944e 100644
--- src://deploy/docker/configuration/application.yml
+++ dst://deploy/docker/configuration/application.yml
@@ -13,23 +13,23 @@ spring:
     name: openvsx-server
   autoconfigure:
     # don't send traces to Zipkin in development
     exclude: org.springframework.boot.actuate.autoconfigure.tracing.zipkin.ZipkinAutoConfiguration
   profiles:
     include: ovsx
   cache:
     jcache:
       config: classpath:ehcache.xml
   datasource:
-    url: jdbc:postgresql://localhost:5432/openvsx
-    username: openvsx
-    password: openvsx
+    url: ${DATASOURCE_URL:jdbc:postgresql://postgres:5432/openvsx}
+    username: ${DATASOURCE_USER:openvsx}
+    password: ${DATASOURCE_PASSWORD:openvsx}
   flyway:
     baseline-on-migrate: true
     baseline-version: 0.1.0
     baseline-description: JobRunr tables
   jpa:
     open-in-view: false
     properties:
       hibernate:
         dialect: org.hibernate.dialect.PostgreSQLDialect
     hibernate:
@@ -85,20 +85,21 @@ org:
       worker-count: 2
     dashboard:
       enabled: false
     database:
       type: sql
     miscellaneous:
       allow-anonymous-data-usage: false
 
 bucket4j:
   enabled: true
+  cache-to-use: redis-jedis # use redis-cluster-jedis when running redis cluster
   filters:
     - cache-name: buckets
       url: '/api/-/(namespace/create|publish)'
       http-response-headers:
         Access-Control-Allow-Origin: '*'
         Access-Control-Expose-Headers: X-Rate-Limit-Retry-After-Seconds, X-Rate-Limit-Remaining
       rate-limits:
         - cache-key: getParameter("token")
           bandwidths:
             - capacity: 15
@@ -121,24 +122,42 @@ bucket4j:
         Access-Control-Allow-Origin: '*'
         Access-Control-Expose-Headers: X-Rate-Limit-Retry-After-Seconds, X-Rate-Limit-Remaining
       rate-limits:
         - cache-key: getRemoteAddr()
           bandwidths:
             - capacity: 15
               time: 1
               unit: seconds
 
 ovsx:
+  cors:
+    allowedOrigins: ${OVSX_CORS_ALLOWED_ORIGINS:http://localhost:3000}
+    allowedMethods: ${OVSX_CORS_ALLOWED_METHODS:GET,POST,PUT,DELETE,OPTIONS}
+  publish:
+    allowNamespaceAutoCreation: ${OVSX_ALLOW_NAMESPACE_AUTO_CREATION:true}
   databasesearch:
     enabled: false
   elasticsearch:
     clear-on-start: true
-    host: 'localhost:9200'
+    host: ${ELASTICSEARCH_HOST:elasticsearch:9200}
+  redis:
+    embedded: true
   extension-control:
     update-on-start: true
   integrity:
     key-pair: create # create, renew, delete, 'undefined'
   registry:
     version: <OPENVSX_VERSION>
   storage:
     local:
       directory: /tmp
+  ldap:
+    url: ${LDAP_URL:}
+    base: ${LDAP_BASE:}
+    userDn: ${LDAP_USER_DN:}
+    password: ${LDAP_PASSWORD:}
+    userSearchBase: ${LDAP_USER_SEARCH_BASE:ou=users}
+    userSearchFilter: ${LDAP_USER_SEARCH_FILTER:(uid={0})}
+    groupSearchBase: ${LDAP_GROUP_SEARCH_BASE:ou=groups}
+    groupSearchFilter: ${LDAP_GROUP_SEARCH_FILTER:(member=uid={0},{1},{2})}
+    adminGroups: ${LDAP_ADMIN_GROUPS:admins,openvsx-admins}
+    fallbackEmailDomain: ${LDAP_FALLBACK_EMAIL_DOMAIN:company.com}
diff --git src://docker-compose.yml dst://docker-compose.yml
index 102fdce1..7404125f 100644
--- src://docker-compose.yml
+++ dst://docker-compose.yml
@@ -4,245 +4,51 @@ services:
     image: postgres:latest
     environment:
       - POSTGRES_USER=openvsx
       - POSTGRES_PASSWORD=openvsx
     logging:
       options:
         max-size: 10m
         max-file: "3"
     ports:
       - '5432:5432'
-    profiles:
-      - db
-      - debug
 
   elasticsearch:
     image: elasticsearch:8.7.1
     environment:
       - xpack.security.enabled=false
       - xpack.ml.enabled=false
       - discovery.type=single-node
       - bootstrap.memory_lock=true
       - cluster.routing.allocation.disk.threshold_enabled=false
     ports:
       - 9200:9200
       - 9300:9300
     healthcheck:
       test: curl -s http://elasticsearch01:9200 >/dev/null || exit 1
       interval: 10s
       timeout: 5s
       retries: 50
       start_period: 5s
-    profiles:
-      - es
-      - debug
 
   kibana:
     image: kibana:8.7.1
     ports:
       - "5601:5601"
     environment:
       - ELASTICSEARCH_URL=http://elasticsearch:9200
     depends_on:
       - elasticsearch
-    profiles:
-      - kibana
 
-  redis-node-1:
-    image: redis:7.2
-    container_name: redis-node-1
-    ports:
-      - "7001:7000"
-    command: redis-server /etc/redis.conf
-    volumes:
-      - ./redis.conf:/etc/redis.conf
-      - /redis/node-1:/data
-    environment:
-      - REDISCLI_AUTH=openvsx
-    healthcheck:
-      test: ["CMD", "redis-cli", "-p", "7000", "--user", "openvsx", "ping"]
-      interval: 5s
-      retries: 5
-    profiles:
-      - redis
-
-  redis-node-2:
-    image: redis:7.2
-    container_name: redis-node-2
-    depends_on:
-      redis-node-1:
-        condition: service_healthy
-    ports:
-      - "7002:7000"
-    command: redis-server /etc/redis.conf
-    volumes:
-      - ./redis.conf:/etc/redis.conf
-      - /redis/node-2:/data
-    environment:
-      - REDISCLI_AUTH=openvsx
-    healthcheck:
-      test: ["CMD", "redis-cli", "-p", "7000", "--user", "openvsx", "ping"]
-      interval: 5s
-      retries: 5
-    profiles:
-      - redis
-
-  redis-node-3:
-    image: redis:7.2
-    container_name: redis-node-3
-    depends_on:
-      redis-node-2:
-        condition: service_healthy
-    ports:
-      - "7003:7000"
-    command: redis-server /etc/redis.conf
-    volumes:
-      - ./redis.conf:/etc/redis.conf
-      - /redis/node-3:/data
-    environment:
-      - REDISCLI_AUTH=openvsx
-    healthcheck:
-      test: ["CMD", "redis-cli", "-p", "7000", "--user", "openvsx", "ping"]
-      interval: 5s
-      retries: 5
-    profiles:
-      - redis
-
-  redis-node-4:
-    image: redis:7.2
-    container_name: redis-node-4
-    depends_on:
-      redis-node-3:
-        condition: service_healthy
-    ports:
-      - "7004:7000"
-    command: redis-server /etc/redis.conf
-    volumes:
-      - ./redis.conf:/etc/redis.conf
-      - /redis/node-4:/data
-    environment:
-      - REDISCLI_AUTH=openvsx
-    healthcheck:
-      test: ["CMD", "redis-cli", "-p", "7000", "--user", "openvsx", "ping"]
-      interval: 5s
-      retries: 5
-    profiles:
-      - redis
-
-  redis-node-5:
-    image: redis:7.2
-    container_name: redis-node-5
-    depends_on:
-      redis-node-4:
-        condition: service_healthy
-    ports:
-      - "7005:7000"
-    command: redis-server /etc/redis.conf
-    volumes:
-      - ./redis.conf:/etc/redis.conf
-      - /redis/node-5:/data
-    environment:
-      - REDISCLI_AUTH=openvsx
-    healthcheck:
-      test: ["CMD", "redis-cli", "-p", "7000", "--user", "openvsx", "ping"]
-      interval: 5s
-      retries: 5
-    profiles:
-      - redis
-
-  redis-node-6:
-    image: redis:7.2
-    container_name: redis-node-6
-    depends_on:
-      redis-node-5:
-        condition: service_healthy
-    ports:
-      - "7006:7000"
-    command: redis-server /etc/redis.conf
-    volumes:
-      - ./redis.conf:/etc/redis.conf
-      - /redis/node-6:/data
-    environment:
-      - REDISCLI_AUTH=openvsx
-    healthcheck:
-      test: ["CMD", "redis-cli", "-p", "7000", "--user", "openvsx", "ping"]
-      interval: 5s
-      retries: 5
-    profiles:
-      - redis
-
-  redis-cluster-init:
-    image: redis:7.2
-    depends_on:
-      - redis-node-1
-      - redis-node-2
-      - redis-node-3
-      - redis-node-4
-      - redis-node-5
-      - redis-node-6
-    environment:
-      - REDISCLI_AUTH=openvsx
-    entrypoint: >
-      bash -c "
-      sleep 10;
-      echo yes | redis-cli --user openvsx --cluster create 
-      redis-node-1:7000 redis-node-2:7000 redis-node-3:7000 
-      redis-node-4:7000 redis-node-5:7000 redis-node-6:7000 
-      --cluster-replicas 1"
-    profiles:
-      - redis
-
-  redisinsight:
-    image: redis/redisinsight
-    ports:
-      - '5540:5540'
-    profiles:
-      - redisinsight
-
-  server:
-    image: openjdk:17
-    working_dir: /app
-    command: sh -c 'scripts/generate-properties.sh --docker && ./gradlew assemble && ./gradlew runServer'
-    volumes:
-      - ./server:/app
+  openvsx:
+    image: teknolojikpanda/openvsx:0.27.1
     ports:
       - 8080:8080
     depends_on:
       - postgres
       - elasticsearch
     healthcheck:
       test: "curl --fail --silent localhost:8081/actuator/health | grep UP || exit 1"
       interval: 10s
       timeout: 5s
       retries: 50
       start_period: 5s
-    profiles:
-      - openvsx
-      - backend
-    
-  webui:
-    image: node:18
-    working_dir: /app
-    command: sh -c 'yarn && yarn build && yarn build:default && yarn watch & yarn watch:default & yarn start:default'
-    volumes:
-      - ./webui:/app
-    ports:
-      - 3000:3000
-    depends_on:
-      - server
-    profiles:
-      - openvsx
-      - frontend
-
-  cli:
-    image: node:18
-    working_dir: /app
-    command: sh -c 'yarn && yarn watch'
-    volumes:
-      - ./cli:/app
-    depends_on:
-      - server
-    environment:
-      - OVSX_REGISTRY_URL=http://server:8080
-    profiles:
-      - openvsx
-      - commandline
diff --git src://server/Dockerfile dst://server/Dockerfile
index cddbacd2..7ca38fa3 100644
--- src://server/Dockerfile
+++ dst://server/Dockerfile
@@ -3,22 +3,21 @@ FROM gradle:jdk17 AS builder
 
 # Copy sources
 WORKDIR /home/gradle
 COPY --chown=gradle:gradle gradlew *.gradle gradle.properties ./
 COPY --chown=gradle:gradle gradle ./gradle/
 COPY --chown=gradle:gradle src ./src/
 
 ENV CI=true
 
 # Build the server application
-RUN --mount=type=secret,id=dv-key,env=DEVELOCITY_ACCESS_KEY \
-    ./gradlew --no-daemon assemble
+RUN ./gradlew --no-daemon assemble
 
 FROM eclipse-temurin:17.0.7_7-jdk
 
 # Create user openvsx and set up home directory
 RUN groupadd -r openvsx && useradd --no-log-init -r -g openvsx openvsx
 RUN mkdir -p /home/openvsx/server && chown -R openvsx:openvsx /home/openvsx
 USER openvsx
 WORKDIR /home/openvsx/server
 
 # Copy and unpack the server archive
diff --git src://server/build.gradle dst://server/build.gradle
index 0b43bc89..0124aa4e 100644
--- src://server/build.gradle
+++ dst://server/build.gradle
@@ -79,22 +79,25 @@ dependencies {
     }
     implementation "org.springframework.boot:spring-boot-starter-validation"
     implementation "org.springframework.boot:spring-boot-starter-jooq"
     implementation "org.springframework.boot:spring-boot-starter-data-jpa"
     implementation "org.springframework.boot:spring-boot-starter-data-elasticsearch"
     implementation "org.springframework.boot:spring-boot-starter-data-redis"
     implementation "org.springframework.boot:spring-boot-starter-security"
     implementation "org.springframework.boot:spring-boot-starter-actuator"
     implementation "org.springframework.boot:spring-boot-starter-cache"
     implementation "org.springframework.boot:spring-boot-starter-aop"
+    implementation "org.springframework.boot:spring-boot-starter-thymeleaf"
     implementation "org.springframework.security:spring-security-oauth2-client"
     implementation "org.springframework.security:spring-security-oauth2-jose"
+    implementation "org.springframework.security:spring-security-ldap"
+    implementation "org.springframework.ldap:spring-ldap-core"
     implementation "org.springframework.session:spring-session-jdbc"
     implementation "org.springframework.retry:spring-retry"
     implementation "org.bouncycastle:bcpkix-jdk18on:${versions.bouncycastle}"
     implementation "com.github.ben-manes.caffeine:caffeine"
     implementation "com.giffing.bucket4j.spring.boot.starter:bucket4j-spring-boot-starter:${versions.bucket4j}"
     implementation "com.bucket4j:bucket4j-redis:${versions.bucket4j_redis}"
     implementation "org.jobrunr:jobrunr-spring-boot-3-starter:${versions.jobrunr}"
     implementation "org.flywaydb:flyway-core:${versions.flyway}"
     implementation "com.google.cloud:google-cloud-storage:${versions.gcloud}"
     implementation "com.azure:azure-storage-blob:${versions.azure}"
diff --git src://server/src/dev/resources/application.yml dst://server/src/dev/resources/application.yml
index 4b37d7ec..4ecc4536 100644
--- src://server/src/dev/resources/application.yml
+++ dst://server/src/dev/resources/application.yml
@@ -158,10 +158,20 @@ ovsx:
       timezone: US/Eastern
   extension-control:
     update-on-start: true
   integrity:
     key-pair: create # create, renew, delete, 'undefined'
   registry:
     version: 'v0.14.3'
   storage:
     local:
       directory: /tmp
+  ldap:
+    url: ${LDAP_URL:}
+    base: ${LDAP_BASE:}
+    userDn: ${LDAP_USER_DN:}
+    password: ${LDAP_PASSWORD:}
+    userSearchBase: ${LDAP_USER_SEARCH_BASE:ou=users}
+    userSearchFilter: ${LDAP_USER_SEARCH_FILTER:(uid={0})}
+    groupSearchBase: ${LDAP_GROUP_SEARCH_BASE:ou=groups}
+    groupSearchFilter: ${LDAP_GROUP_SEARCH_FILTER:(member=uid={0},{1},{2})}
+    adminGroups: ${LDAP_ADMIN_GROUPS:admins,openvsx-admins}
diff --git src://server/src/main/java/org/eclipse/openvsx/UserAPI.java dst://server/src/main/java/org/eclipse/openvsx/UserAPI.java
index 8ae37861..b556672a 100644
--- src://server/src/main/java/org/eclipse/openvsx/UserAPI.java
+++ dst://server/src/main/java/org/eclipse/openvsx/UserAPI.java
@@ -9,20 +9,21 @@
  ********************************************************************************/
 package org.eclipse.openvsx;
 
 import jakarta.servlet.http.HttpServletRequest;
 import org.eclipse.openvsx.eclipse.EclipseService;
 import org.eclipse.openvsx.entities.NamespaceMembership;
 import org.eclipse.openvsx.entities.UserData;
 import org.eclipse.openvsx.json.*;
 import org.eclipse.openvsx.repositories.RepositoryService;
 import org.eclipse.openvsx.security.CodedAuthException;
+import org.eclipse.openvsx.security.LdapConfig;
 import org.eclipse.openvsx.storage.StorageUtilService;
 import org.eclipse.openvsx.util.ErrorResultException;
 import org.eclipse.openvsx.util.NotFoundException;
 import org.eclipse.openvsx.util.UrlUtil;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.springframework.http.CacheControl;
 import org.springframework.http.HttpStatus;
 import org.springframework.http.MediaType;
 import org.springframework.http.ResponseEntity;
@@ -44,39 +45,48 @@ import static org.eclipse.openvsx.util.UrlUtil.createApiUrl;
 public class UserAPI {
 
     private static final int TOKEN_DESCRIPTION_SIZE = 255;
 
     protected final Logger logger = LoggerFactory.getLogger(UserAPI.class);
 
     private final RepositoryService repositories;
     private final UserService users;
     private final EclipseService eclipse;
     private final StorageUtilService storageUtil;
+    private final LdapConfig ldapConfig;
 
     public UserAPI(
             RepositoryService repositories,
             UserService users,
             EclipseService eclipse,
-            StorageUtilService storageUtil
+            StorageUtilService storageUtil,
+            LdapConfig ldapConfig
     ) {
         this.repositories = repositories;
         this.users = users;
         this.eclipse = eclipse;
         this.storageUtil = storageUtil;
+        this.ldapConfig = ldapConfig;
     }
 
     @GetMapping(
         path = "/login-providers"
     )
     public ResponseEntity<LoginProvidersJson> login() {
         var json = new LoginProvidersJson();
         var providers = users.getLoginProviders();
+        
+        // Add LDAP provider if enabled
+        if (ldapConfig.isLdapEnabled()) {
+            providers.put("ldap", "LDAP");
+        }
+        
         if(!providers.isEmpty()) {
             json.setLoginProviders(providers);
         } else {
             json.setSuccess("No login providers available.");
         }
 
         return ResponseEntity.ok(json);
     }
 
     /**
@@ -107,33 +117,42 @@ public class UserAPI {
     public UserJson getUserData() {
         var user = users.findLoggedInUser();
         if (user == null) {
             return UserJson.error("Not logged in.");
         }
         var json = user.toUserJson();
         var serverUrl = UrlUtil.getBaseUrl();
         json.setRole(user.getRole());
         json.setTokensUrl(createApiUrl(serverUrl, "user", "tokens"));
         json.setCreateTokenUrl(createApiUrl(serverUrl, "user", "token", "create"));
+        
+        // Only enrich with Eclipse data for OAuth users
+        if (!"ldap".equals(user.getProvider())) {
             eclipse.enrichUserJson(json, user);
+        }
         return json;
     }
 
     @GetMapping(
         path = "/user/csrf",
         produces = MediaType.APPLICATION_JSON_VALUE
     )
-    public CsrfTokenJson getCsrfToken(HttpServletRequest request) {
+    public ResponseEntity<?> getCsrfToken(HttpServletRequest request) {
         var csrfToken = (CsrfToken) request.getAttribute("_csrf");
-        return csrfToken != null
-                ? new CsrfTokenJson(csrfToken.getToken(), csrfToken.getHeaderName())
-                : CsrfTokenJson.error("Token is not available.");
+        if (csrfToken != null) {
+            var response = new java.util.HashMap<String, String>();
+            response.put("token", csrfToken.getToken());
+            response.put("header", csrfToken.getHeaderName());
+            return ResponseEntity.ok(response);
+        } else {
+            return ResponseEntity.ok(java.util.Map.of("error", "Token is not available."));
+        }
     }
 
     @GetMapping(
         path = "/user/tokens",
         produces = MediaType.APPLICATION_JSON_VALUE
     )
     public List<AccessTokenJson> getAccessTokens() {
         var user = users.findLoggedInUser();
         if (user == null) {
             throw new ResponseStatusException(HttpStatus.FORBIDDEN);
@@ -345,19 +364,23 @@ public class UserAPI {
         if (user == null) {
             return new ResponseEntity<>(HttpStatus.FORBIDDEN);
         }
         try {
             var agreement = eclipse.signPublisherAgreement(user);
             var json = user.toUserJson();
             var serverUrl = UrlUtil.getBaseUrl();
             json.setRole(user.getRole());
             json.setTokensUrl(createApiUrl(serverUrl, "user", "tokens"));
             json.setCreateTokenUrl(createApiUrl(serverUrl, "user", "token", "create"));
+            
+            // Only enrich with Eclipse data for OAuth users
+            if (!"ldap".equals(user.getProvider())) {
                 eclipse.enrichUserJson(json, user, agreement);
+            }
 
             return ResponseEntity.ok(json);
         } catch (ErrorResultException exc) {
             return exc.toResponseEntity(UserJson.class);
         }
     }
 
 }
diff --git src://server/src/main/java/org/eclipse/openvsx/UserService.java dst://server/src/main/java/org/eclipse/openvsx/UserService.java
index 464ba3b8..b4cc4b83 100644
--- src://server/src/main/java/org/eclipse/openvsx/UserService.java
+++ dst://server/src/main/java/org/eclipse/openvsx/UserService.java
@@ -7,20 +7,22 @@
  *
  * SPDX-License-Identifier: EPL-2.0
  ********************************************************************************/
 package org.eclipse.openvsx;
 
 import com.google.common.base.Joiner;
 import jakarta.persistence.EntityManager;
 import jakarta.transaction.Transactional;
 import org.apache.commons.lang3.SerializationUtils;
 import org.apache.commons.lang3.StringUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 import org.apache.tika.Tika;
 import org.apache.tika.mime.MediaType;
 import org.apache.tika.mime.MimeTypeException;
 import org.apache.tika.mime.MimeTypes;
 import org.eclipse.openvsx.cache.CacheService;
 import org.eclipse.openvsx.entities.Namespace;
 import org.eclipse.openvsx.entities.NamespaceMembership;
 import org.eclipse.openvsx.entities.PersonalAccessToken;
 import org.eclipse.openvsx.entities.UserData;
 import org.eclipse.openvsx.json.AccessTokenJson;
@@ -36,28 +38,31 @@ import org.springframework.beans.factory.annotation.Value;
 import org.springframework.cache.annotation.CacheEvict;
 import org.springframework.security.core.context.SecurityContextHolder;
 import org.springframework.security.oauth2.client.registration.ClientRegistrationRepository;
 import org.springframework.stereotype.Component;
 import org.springframework.web.multipart.MultipartFile;
 import org.springframework.web.server.ServerErrorException;
 
 import java.io.IOException;
 import java.nio.file.Files;
 import java.util.*;
+import java.util.Set;
 import java.util.stream.Collectors;
 
 import static org.eclipse.openvsx.cache.CacheService.CACHE_NAMESPACE_DETAILS_JSON;
 import static org.eclipse.openvsx.util.UrlUtil.createApiUrl;
 
 @Component
 public class UserService {
 
+    private static final Logger logger = LoggerFactory.getLogger(UserService.class);
+
     private final EntityManager entityManager;
     private final RepositoryService repositories;
     private final StorageUtilService storageUtil;
     private final CacheService cache;
     private final ExtensionValidator validator;
     private final ClientRegistrationRepository clientRegistrationRepository;
     private final OAuth2AttributesConfig attributesConfig;
 
     @Value("${ovsx.token-prefix:}")
     String tokenPrefix;
@@ -310,28 +315,50 @@ public class UserService {
                 updated = true;
             }
             if (!StringUtils.equals(userData.getProviderUrl(), newUser.getProviderUrl())) {
                 userData.setProviderUrl(newUser.getProviderUrl());
                 updated = true;
             }
             if (!StringUtils.equals(userData.getAvatarUrl(), newUser.getAvatarUrl())) {
                 userData.setAvatarUrl(newUser.getAvatarUrl());
                 updated = true;
             }
+            if (!StringUtils.equals(userData.getRole(), newUser.getRole())) {
+                // Only allow role updates from trusted sources (LDAP provider)
+                if ("ldap".equals(newUser.getProvider())) {
+                    // Validate new role against allowed roles
+                    Set<String> allowedRoles = Set.of("user", "admin", "privileged");
+                    String requestedRole = newUser.getRole();
+                    if (allowedRoles.contains(requestedRole)) {
+                        // Log the role change for audit purposes
+                        logger.info("Role change for user '{}': '{}' -> '{}' by provider '{}'",
+                            userData.getLoginName(), userData.getRole(), requestedRole, newUser.getProvider());
+                        userData.setRole(requestedRole);
+                        updated = true;
+                    } else {
+                        logger.warn("Unauthorized role change attempt for user '{}': '{}' -> '{}' by provider '{}'",
+                            userData.getLoginName(), userData.getRole(), requestedRole, newUser.getProvider());
+                    }
+                }
+            }
             if (updated) {
                 cache.evictExtensionJsons(userData);
             }
         }
 
         return userData;
     }
 
+    public boolean isAdmin(UserData user) {
+        return UserData.ROLE_ADMIN.equals(user.getRole());
+    }
+
     public Map<String, String> getLoginProviders() {
         if(clientRegistrationRepository == null) {
             return Collections.emptyMap();
         }
 
         return attributesConfig.getProviders().stream()
                 .filter(provider -> clientRegistrationRepository.findByRegistrationId(provider) != null)
                 .map(provider -> Map.entry(provider, UrlUtil.createApiUrl(UrlUtil.getBaseUrl(), "oauth2", "authorization", provider)))
                 .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
     }
diff --git src://server/src/main/java/org/eclipse/openvsx/publish/PublishConfig.java dst://server/src/main/java/org/eclipse/openvsx/publish/PublishConfig.java
new file mode 100644
index 00000000..f7813882
--- /dev/null
+++ dst://server/src/main/java/org/eclipse/openvsx/publish/PublishConfig.java
@@ -0,0 +1,24 @@
+/********************************************************************************
+ * Copyright (c) 2025 Eclipse Foundation and others
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License v. 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ ********************************************************************************/
+package org.eclipse.openvsx.publish;
+
+import org.springframework.beans.factory.annotation.Value;
+import org.springframework.stereotype.Component;
+
+@Component
+public class PublishConfig {
+
+    @Value("${ovsx.publish.allowNamespaceAutoCreation:true}")
+    private boolean allowNamespaceAutoCreation;
+
+    public boolean isAllowNamespaceAutoCreation() {
+        return allowNamespaceAutoCreation;
+    }
+}
\ No newline at end of file
diff --git src://server/src/main/java/org/eclipse/openvsx/publish/PublishExtensionVersionHandler.java dst://server/src/main/java/org/eclipse/openvsx/publish/PublishExtensionVersionHandler.java
index 4b8d5910..aa195a57 100644
--- src://server/src/main/java/org/eclipse/openvsx/publish/PublishExtensionVersionHandler.java
+++ dst://server/src/main/java/org/eclipse/openvsx/publish/PublishExtensionVersionHandler.java
@@ -12,20 +12,21 @@ package org.eclipse.openvsx.publish;
 import com.google.common.base.Joiner;
 import jakarta.persistence.EntityManager;
 import jakarta.transaction.Transactional;
 import org.apache.commons.lang3.StringUtils;
 import org.eclipse.openvsx.ExtensionProcessor;
 import org.eclipse.openvsx.ExtensionService;
 import org.eclipse.openvsx.ExtensionValidator;
 import org.eclipse.openvsx.UserService;
 import org.eclipse.openvsx.adapter.VSCodeIdNewExtensionJobRequest;
 import org.eclipse.openvsx.entities.*;
+import org.eclipse.openvsx.entities.UserData;
 import org.eclipse.openvsx.extension_control.ExtensionControlService;
 import org.eclipse.openvsx.repositories.RepositoryService;
 import org.eclipse.openvsx.util.ErrorResultException;
 import org.eclipse.openvsx.util.ExtensionId;
 import org.eclipse.openvsx.util.NamingUtil;
 import org.eclipse.openvsx.util.TempFile;
 import org.jobrunr.scheduling.JobRequestScheduler;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.springframework.retry.annotation.Retryable;
@@ -43,39 +44,42 @@ public class PublishExtensionVersionHandler {
     protected final Logger logger = LoggerFactory.getLogger(PublishExtensionVersionHandler.class);
 
     private final PublishExtensionVersionService service;
     private final ExtensionVersionIntegrityService integrityService;
     private final EntityManager entityManager;
     private final RepositoryService repositories;
     private final JobRequestScheduler scheduler;
     private final UserService users;
     private final ExtensionValidator validator;
     private final ExtensionControlService extensionControl;
+    private final PublishConfig config;
 
     public PublishExtensionVersionHandler(
             PublishExtensionVersionService service,
             ExtensionVersionIntegrityService integrityService,
             EntityManager entityManager,
             RepositoryService repositories,
             JobRequestScheduler scheduler,
             UserService users,
             ExtensionValidator validator,
-            ExtensionControlService extensionControl
+            ExtensionControlService extensionControl,
+            PublishConfig config
     ) {
         this.service = service;
         this.integrityService = integrityService;
         this.entityManager = entityManager;
         this.repositories = repositories;
         this.scheduler = scheduler;
         this.users = users;
         this.validator = validator;
         this.extensionControl = extensionControl;
+        this.config = config;
     }
 
     @Transactional(rollbackOn = ErrorResultException.class)
     public ExtensionVersion createExtensionVersion(ExtensionProcessor processor, PersonalAccessToken token, LocalDateTime timestamp, boolean checkDependencies) {
         // Extract extension metadata from its manifest
         var extVersion = createExtensionVersion(processor, token.getUser(), token, timestamp);
         var dependencies = processor.getExtensionDependencies();
         var bundledExtensions = processor.getBundledExtensions();
         if (checkDependencies) {
             var parsedDependencies = dependencies.stream()
@@ -93,27 +97,45 @@ public class PublishExtensionVersionHandler {
         if(integrityService.isEnabled()) {
             extVersion.setSignatureKeyPair(repositories.findActiveKeyPair());
         }
 
         return extVersion;
     }
 
     private ExtensionVersion createExtensionVersion(ExtensionProcessor processor, UserData user, PersonalAccessToken token, LocalDateTime timestamp) {
         var namespaceName = processor.getNamespace();
         var namespace = repositories.findNamespace(namespaceName);
+        
         if (namespace == null) {
-            throw new ErrorResultException("Unknown publisher: " + namespaceName
-                    + "\nUse the 'create-namespace' command to create a namespace corresponding to your publisher name.");
+            boolean userCanCreateNamespace = users.isAdmin(user) || UserData.ROLE_PRIVILEGED.equals(user.getRole());
+            
+            if (config.isAllowNamespaceAutoCreation() && userCanCreateNamespace) {
+                // Auto-create namespace
+                namespace = new Namespace();
+                namespace.setName(namespaceName);
+                entityManager.persist(namespace);
+                
+                // Add user as owner of the new namespace
+                var membership = new NamespaceMembership();
+                membership.setNamespace(namespace);
+                membership.setUser(user);
+                membership.setRole(NamespaceMembership.ROLE_OWNER);
+                entityManager.persist(membership);
+            } else {
+                throw new ErrorResultException("Namespace does not exist and auto-creation is not permitted or user lacks permission: " + namespaceName);
             }
+        } else {
+            // Check permissions only for existing namespaces
             if (!users.hasPublishPermission(user, namespace)) {
                 throw new ErrorResultException("Insufficient access rights for publisher: " + namespace.getName());
             }
+        }
 
         var extensionName = processor.getExtensionName();
         validateExtensionVersion(processor, namespaceName, extensionName);
 
         var extVersion = processor.getMetadata();
         extVersion.setTimestamp(timestamp);
         extVersion.setPublishedWith(token);
         extVersion.setActive(false);
 
         var extension = repositories.findExtension(extensionName, namespace);
diff --git src://server/src/main/java/org/eclipse/openvsx/security/GroupRoleResolver.java dst://server/src/main/java/org/eclipse/openvsx/security/GroupRoleResolver.java
new file mode 100644
index 00000000..96d19680
--- /dev/null
+++ dst://server/src/main/java/org/eclipse/openvsx/security/GroupRoleResolver.java
@@ -0,0 +1,70 @@
+/********************************************************************************
+ * Copyright (c) 2025 Eclipse Foundation and others
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License v. 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ ********************************************************************************/
+package org.eclipse.openvsx.security;
+
+import org.eclipse.openvsx.entities.UserData;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.springframework.ldap.core.LdapTemplate;
+import org.springframework.ldap.core.AttributesMapper;
+
+import javax.naming.directory.SearchControls;
+import javax.naming.directory.Attributes;
+import java.util.Optional;
+import java.util.Set;
+
+public class GroupRoleResolver {
+    private static final Logger logger = LoggerFactory.getLogger(GroupRoleResolver.class);
+    
+    private final LdapTemplate ldap;
+    private final String groupBase;
+    private final String filterTpl;
+    private final Set<String> adminGroups;
+
+    public GroupRoleResolver(LdapTemplate ldap, String groupBase, String filterTpl, String adminGroupsCsv) {
+        this.ldap = ldap;
+        this.groupBase = groupBase;
+        this.filterTpl = filterTpl;
+        this.adminGroups = Set.of(adminGroupsCsv.split(","));
+    }
+
+    public String resolve(String username, String userSearchBase, String ldapBase) {
+        try {
+            String filter = filterTpl
+                .replace("{0}", username)
+                .replace("{1}", userSearchBase)
+                .replace("{2}", ldapBase);
+            var groups = ldap.search(groupBase, filter, mkControls(),
+                (AttributesMapper<String>) attrs -> {
+                    try {
+                        var cnAttr = attrs.get("cn");
+                        return cnAttr != null ? (String) cnAttr.get() : null;
+                    } catch (Exception e) {
+                        return null;
+                    }
+                });
+            for (var g : groups) {
+                if (g != null && adminGroups.contains(g.trim())) {
+                    return UserData.ROLE_ADMIN;
+                }
+            }
+        } catch (Exception e) {
+            logger.warn("LDAP group lookup failed", e);
+        }
+        return UserData.ROLE_PRIVILEGED;
+    }
+
+    private SearchControls mkControls() {
+        var sc = new SearchControls();
+        sc.setSearchScope(SearchControls.SUBTREE_SCOPE);
+        sc.setReturningAttributes(new String[]{"cn"});
+        return sc;
+    }
+}
\ No newline at end of file
diff --git src://server/src/main/java/org/eclipse/openvsx/security/LdapAuthenticationSuccessHandler.java dst://server/src/main/java/org/eclipse/openvsx/security/LdapAuthenticationSuccessHandler.java
new file mode 100644
index 00000000..d3eb72f3
--- /dev/null
+++ dst://server/src/main/java/org/eclipse/openvsx/security/LdapAuthenticationSuccessHandler.java
@@ -0,0 +1,110 @@
+/********************************************************************************
+ * Copyright (c) 2024 Eclipse Foundation and others
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License v. 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ ********************************************************************************/
+package org.eclipse.openvsx.security;
+
+import java.io.IOException;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.springframework.security.core.Authentication;
+import org.springframework.security.web.authentication.AuthenticationSuccessHandler;
+
+import jakarta.servlet.ServletException;
+import jakarta.servlet.http.HttpServletRequest;
+import jakarta.servlet.http.HttpServletResponse;
+
+public class LdapAuthenticationSuccessHandler implements AuthenticationSuccessHandler {
+
+    private static final Logger logger = LoggerFactory.getLogger(LdapAuthenticationSuccessHandler.class);
+
+    private final String redirectUrl;
+    private final org.eclipse.openvsx.UserService userService;
+    private final UserAttributesMapper attrsMapper;
+    private final GroupRoleResolver roleResolver;
+    private final String userSearchBase;
+    private final String ldapBase;
+
+    public LdapAuthenticationSuccessHandler(String redirectUrl, org.eclipse.openvsx.UserService userService, 
+                                          org.springframework.ldap.core.LdapTemplate ldapTemplate,
+                                          String userSearchBase, String groupSearchBase, String groupSearchFilter, String adminGroups, String ldapBase) {
+        this.redirectUrl = redirectUrl;
+        this.userService = userService;
+        this.userSearchBase = userSearchBase;
+        this.ldapBase = ldapBase;
+        this.attrsMapper = new UserAttributesMapper(ldapTemplate, userSearchBase);
+        this.roleResolver = new GroupRoleResolver(ldapTemplate, groupSearchBase, groupSearchFilter, adminGroups);
+    }
+
+    @Override
+    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,
+                                        Authentication authentication) throws IOException, ServletException {
+        logger.info("LDAP Authentication Success! Redirecting to: " + redirectUrl);
+        
+        Object p = authentication.getPrincipal();
+        if (p instanceof LdapUserService.LdapUserDetails custom) {
+            handleCustom(custom, authentication);
+        } else if (p instanceof org.springframework.security.ldap.userdetails.LdapUserDetailsImpl springLdap) {
+            handleSpring(springLdap, authentication);
+        } else {
+            logger.info("Authenticated: {}", authentication.getName());
+        }
+        
+        writeSuccess(response);
+    }
+
+    private void handleCustom(LdapUserService.LdapUserDetails ldapUser, Authentication oldAuth) {
+        var userData = ldapUser.getUserData();
+        var idPrincipal = new IdPrincipal(userData.getId(), userData.getLoginName(), new java.util.ArrayList<>(ldapUser.getAuthorities()));
+        
+        var newAuth = new org.springframework.security.authentication.UsernamePasswordAuthenticationToken(
+            idPrincipal, oldAuth.getCredentials(), oldAuth.getAuthorities());
+        org.springframework.security.core.context.SecurityContextHolder.getContext().setAuthentication(newAuth);
+        
+        logger.info("User authenticated: " + userData.getLoginName());
+    }
+
+    private void handleSpring(org.springframework.security.ldap.userdetails.LdapUserDetailsImpl usr, Authentication oldAuth) {
+        String username = usr.getUsername();
+        logger.info("Creating user session for LDAP user: " + username);
+        
+        var ua = attrsMapper.map(username);
+        String role = roleResolver.resolve(username, userSearchBase, ldapBase);
+        
+        var userData = new org.eclipse.openvsx.entities.UserData();
+        userData.setLoginName(username);
+        userData.setProvider("ldap");
+        userData.setAuthId("ldap:" + username);
+        userData.setFullName(ua.fullName());
+        userData.setEmail(ua.email());
+        userData.setRole(role);
+        
+        userData = userService.upsertUser(userData);
+        
+        var authorities = new java.util.ArrayList<org.springframework.security.core.GrantedAuthority>();
+        if (org.eclipse.openvsx.entities.UserData.ROLE_ADMIN.equals(role)) {
+            authorities.add(new org.springframework.security.core.authority.SimpleGrantedAuthority("ROLE_ADMIN"));
+        }
+        authorities.add(new org.springframework.security.core.authority.SimpleGrantedAuthority("ROLE_USER"));
+        
+        var idPrincipal = new IdPrincipal(userData.getId(), username, authorities);
+        var newAuth = new org.springframework.security.authentication.UsernamePasswordAuthenticationToken(
+            idPrincipal, oldAuth.getCredentials(), authorities);
+        org.springframework.security.core.context.SecurityContextHolder.getContext().setAuthentication(newAuth);
+        
+        logger.info("User session created for: " + username);
+    }
+
+    private void writeSuccess(HttpServletResponse response) throws IOException {
+        response.setContentType("application/json");
+        response.setStatus(200);
+        response.getWriter().write("{\"success\":true}");
+    }
+
+}
\ No newline at end of file
diff --git src://server/src/main/java/org/eclipse/openvsx/security/LdapConfig.java dst://server/src/main/java/org/eclipse/openvsx/security/LdapConfig.java
new file mode 100644
index 00000000..83fab57c
--- /dev/null
+++ dst://server/src/main/java/org/eclipse/openvsx/security/LdapConfig.java
@@ -0,0 +1,83 @@
+/********************************************************************************
+ * Copyright (c) 2024 Eclipse Foundation and others
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License v. 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ ********************************************************************************/
+package org.eclipse.openvsx.security;
+
+import org.springframework.beans.factory.annotation.Value;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.ldap.core.LdapTemplate;
+import org.springframework.ldap.core.support.LdapContextSource;
+import org.springframework.security.ldap.DefaultSpringSecurityContextSource;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import jakarta.annotation.PostConstruct;
+
+@Configuration
+public class LdapConfig {
+
+    private static final Logger logger = LoggerFactory.getLogger(LdapConfig.class);
+
+    @Value("${ovsx.ldap.url:}")
+    private String ldapUrl;
+
+    @Value("${ovsx.ldap.base:}")
+    private String ldapBase;
+
+    @Value("${ovsx.ldap.userDn:}")
+    private String ldapUserDn;
+
+    @Value("${ovsx.ldap.password:}")
+    private String ldapPassword;
+
+    @Value("${ovsx.ldap.userSearchBase:ou=users}")
+    private String userSearchBase;
+
+    @Bean
+    @ConditionalOnProperty(name = "ovsx.ldap.url", matchIfMissing = false)
+    public LdapContextSource contextSource() {
+        try {
+            DefaultSpringSecurityContextSource contextSource = new DefaultSpringSecurityContextSource(ldapUrl);
+            contextSource.setBase(ldapBase);
+            if (!ldapUserDn.isEmpty() && !ldapPassword.isEmpty()) {
+                contextSource.setUserDn(ldapUserDn);
+                contextSource.setPassword(ldapPassword);
+            }
+            logger.info("LDAP Context Source created successfully for URL: {}", ldapUrl);
+            return contextSource;
+        } catch (Exception e) {
+            logger.error("Failed to create LDAP context source for URL '{}': {}", ldapUrl, e.getMessage());
+            throw e;
+        }
+    }
+
+    @Bean
+    @ConditionalOnProperty(name = "ovsx.ldap.url", matchIfMissing = false)
+    public LdapTemplate ldapTemplate() {
+        return new LdapTemplate(contextSource());
+    }
+
+    @Bean
+    @ConditionalOnProperty(name = "ovsx.ldap.url", matchIfMissing = false)
+    public UserAttributesMapper userAttributesMapper() {
+        return new UserAttributesMapper(ldapTemplate(), userSearchBase);
+    }
+
+    @PostConstruct
+    public void logLdapConfig() {
+        logger.info("LDAP Configuration - URL: '{}', Base: '{}', Enabled: {}", ldapUrl, ldapBase, isLdapEnabled());
+    }
+
+    public boolean isLdapEnabled() {
+        boolean enabled = !ldapUrl.isEmpty() && !ldapBase.isEmpty();
+        logger.debug("LDAP enabled check: URL='{}', Base='{}', Result={}", ldapUrl, ldapBase, enabled);
+        return enabled;
+    }
+}
\ No newline at end of file
diff --git src://server/src/main/java/org/eclipse/openvsx/security/LdapConnectionTest.java dst://server/src/main/java/org/eclipse/openvsx/security/LdapConnectionTest.java
new file mode 100644
index 00000000..1e89b907
--- /dev/null
+++ dst://server/src/main/java/org/eclipse/openvsx/security/LdapConnectionTest.java
@@ -0,0 +1,64 @@
+/********************************************************************************
+ * Copyright (c) 2024 Eclipse Foundation and others
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License v. 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ ********************************************************************************/
+package org.eclipse.openvsx.security;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.beans.factory.annotation.Value;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
+import org.springframework.ldap.core.LdapTemplate;
+import org.springframework.stereotype.Component;
+
+import jakarta.annotation.PostConstruct;
+
+@Component
+@ConditionalOnProperty(name = "ovsx.ldap.url", matchIfMissing = false)
+public class LdapConnectionTest {
+
+    private static final Logger logger = LoggerFactory.getLogger(LdapConnectionTest.class);
+
+    @Autowired
+    private LdapTemplate ldapTemplate;
+
+    @Value("${ovsx.ldap.userSearchBase:}")
+    private String userSearchBase;
+
+    @PostConstruct
+    public void testLdapConnection() {
+        testConnection();
+    }
+    
+    public boolean testConnection() {
+        try {
+            logger.info("Testing LDAP connection and user search base...");
+            
+            // Test basic connection
+            ldapTemplate.lookup("");
+            logger.info("LDAP connection successful");
+            
+            // Test if user search base exists
+            try {
+                ldapTemplate.lookup(userSearchBase);
+                logger.info("User search base '{}' exists and is accessible", userSearchBase);
+                return true;
+            } catch (Exception e) {
+                logger.error("User search base '{}' does not exist or is not accessible: {}", userSearchBase, e.getMessage());
+                logger.info("Please verify the LDAP directory structure and update ovsx.ldap.userSearchBase property");
+                return false;
+            }
+            
+        } catch (Exception e) {
+            logger.error("LDAP connection test failed: {}", e.getMessage());
+            logger.info("Please check LDAP server configuration and connectivity");
+            return false;
+        }
+    }
+}
\ No newline at end of file
diff --git src://server/src/main/java/org/eclipse/openvsx/security/LdapUserService.java dst://server/src/main/java/org/eclipse/openvsx/security/LdapUserService.java
new file mode 100644
index 00000000..918c6afc
--- /dev/null
+++ dst://server/src/main/java/org/eclipse/openvsx/security/LdapUserService.java
@@ -0,0 +1,130 @@
+/********************************************************************************
+ * Copyright (c) 2024 Eclipse Foundation and others
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License v. 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ ********************************************************************************/
+package org.eclipse.openvsx.security;
+
+import org.eclipse.openvsx.UserService;
+import org.eclipse.openvsx.entities.UserData;
+import org.springframework.beans.factory.annotation.Value;
+import org.springframework.security.core.GrantedAuthority;
+import org.springframework.security.core.userdetails.UserDetails;
+import org.springframework.security.core.userdetails.UserDetailsService;
+import org.springframework.security.core.userdetails.UsernameNotFoundException;
+import org.springframework.stereotype.Service;
+
+import java.util.Collection;
+
+import static java.util.Collections.emptyList;
+import static java.util.Objects.requireNonNullElse;
+import static org.eclipse.openvsx.entities.UserData.ROLE_ADMIN;
+import static org.eclipse.openvsx.entities.UserData.ROLE_PRIVILEGED;
+import static org.springframework.security.core.authority.AuthorityUtils.createAuthorityList;
+
+@Service
+public class LdapUserService implements UserDetailsService {
+
+    private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(LdapUserService.class);
+    
+    private final UserService userService;
+    private final String fallbackEmailDomain;
+    private final UserAttributesMapper attributesMapper;
+
+    @Value("${ovsx.ldap.userSearchFilter:(uid={0})}")
+    private String userSearchFilter;
+
+    public LdapUserService(UserService userService, 
+                          @Value("${ovsx.ldap.fallbackEmailDomain:company.com}") String fallbackEmailDomain,
+                          @org.springframework.beans.factory.annotation.Autowired(required = false) UserAttributesMapper attributesMapper) {
+        this.userService = userService;
+        this.fallbackEmailDomain = fallbackEmailDomain;
+        this.attributesMapper = attributesMapper;
+    }
+
+    @Override
+    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
+        // Create or update user data for LDAP user
+        var userData = new UserData();
+        userData.setLoginName(username);
+        userData.setProvider("ldap");
+        userData.setAuthId("ldap:" + username);
+        // Fetch LDAP attributes using UserAttributesMapper if available
+        if (attributesMapper != null) {
+            var attributes = attributesMapper.map(username);
+            userData.setFullName(attributes.fullName());
+            userData.setEmail(attributes.email());
+            logger.debug("LDAP user '{}' mapped to fullName='{}', email='{}'", username, attributes.fullName(), attributes.email());
+        } else {
+            // Fallback when UserAttributesMapper is not available
+            logger.warn("UserAttributesMapper not available, using fallback values for user '{}'", username);
+            userData.setFullName(username);
+            userData.setEmail(username + "@" + fallbackEmailDomain);
+        }
+
+        userData = userService.upsertUser(userData);
+        
+        return new LdapUserDetails(userData, getAuthorities(userData));
+    }
+
+    private Collection<GrantedAuthority> getAuthorities(UserData userData) {
+        return switch (requireNonNullElse(userData.getRole(), "")) {
+            case ROLE_ADMIN -> createAuthorityList("ROLE_ADMIN");
+            case ROLE_PRIVILEGED -> createAuthorityList("ROLE_PRIVILEGED");
+            default -> emptyList();
+        };
+    }
+
+    public static class LdapUserDetails implements UserDetails {
+        private final UserData userData;
+        private final Collection<GrantedAuthority> authorities;
+
+        public LdapUserDetails(UserData userData, Collection<GrantedAuthority> authorities) {
+            this.userData = userData;
+            this.authorities = authorities;
+        }
+
+        @Override
+        public Collection<? extends GrantedAuthority> getAuthorities() {
+            return authorities;
+        }
+
+        @Override
+        public String getPassword() {
+            return "";
+        }
+
+        @Override
+        public String getUsername() {
+            return userData.getLoginName();
+        }
+
+        @Override
+        public boolean isAccountNonExpired() {
+            return true;
+        }
+
+        @Override
+        public boolean isAccountNonLocked() {
+            return true;
+        }
+
+        @Override
+        public boolean isCredentialsNonExpired() {
+            return true;
+        }
+
+        @Override
+        public boolean isEnabled() {
+            return true;
+        }
+
+        public UserData getUserData() {
+            return userData;
+        }
+    }
+}
\ No newline at end of file
diff --git src://server/src/main/java/org/eclipse/openvsx/security/SecurityConfig.java dst://server/src/main/java/org/eclipse/openvsx/security/SecurityConfig.java
index 4900dcfd..0ffe4aad 100644
--- src://server/src/main/java/org/eclipse/openvsx/security/SecurityConfig.java
+++ dst://server/src/main/java/org/eclipse/openvsx/security/SecurityConfig.java
@@ -2,76 +2,229 @@
  * Copyright (c) 2020 TypeFox and others
  *
  * This program and the accompanying materials are made available under the
  * terms of the Eclipse Public License v. 2.0 which is available at
  * http://www.eclipse.org/legal/epl-2.0.
  *
  * SPDX-License-Identifier: EPL-2.0
  ********************************************************************************/
 package org.eclipse.openvsx.security;
 
+import java.util.Collection;
+import test.error
 import org.apache.commons.lang3.StringUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.beans.factory.annotation.Value;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
+import org.springframework.ldap.core.DirContextOperations;
 import org.springframework.security.config.annotation.web.builders.HttpSecurity;
 import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
+import org.springframework.security.core.GrantedAuthority;
+import org.springframework.security.core.userdetails.UserDetails;
+import org.springframework.security.ldap.authentication.BindAuthenticator;
+import org.springframework.security.ldap.authentication.LdapAuthenticationProvider;
+import org.springframework.security.ldap.search.FilterBasedLdapUserSearch;
+import org.springframework.security.ldap.userdetails.LdapAuthoritiesPopulator;
 import org.springframework.security.web.SecurityFilterChain;
 import org.springframework.security.web.authentication.Http403ForbiddenEntryPoint;
 import org.springframework.security.web.servlet.util.matcher.PathPatternRequestMatcher;
 import org.springframework.security.web.util.matcher.RequestMatcher;
 
+import jakarta.annotation.PostConstruct;
+
 @Configuration
 @EnableWebSecurity
 public class SecurityConfig {
 
+    private static final Logger logger = LoggerFactory.getLogger(SecurityConfig.class);
+
     @Value("${ovsx.webui.url:}")
     String webuiUrl;
 
     @Value("${ovsx.webui.frontendRoutes:/extension/**,/namespace/**,/user-settings/**,/admin-dashboard/**}")
     String[] frontendRoutes;
 
+    @Value("${ovsx.ldap.userSearchBase:}")
+    String ldapUserSearchBase;
+
+    @Value("${ovsx.ldap.userSearchFilter:(uid={0})}")
+    String ldapUserSearchFilter;
+
+    @Value("${ovsx.ldap.groupSearchBase:}")
+    String ldapGroupSearchBase;
+
+    @Value("${ovsx.ldap.groupSearchFilter:(member=uid={0},{1},{2})}")
+    String ldapGroupSearchFilter;
+
+    @Value("${ovsx.ldap.adminGroups:admins,openvsx-admins}")
+    String ldapAdminGroups;
+
+    @Value("${ovsx.ldap.base:}")
+    String ldapBase;
+
+    @Value("${ovsx.cors.allowedOrigins:http://localhost:3000}")
+    String corsAllowedOrigins;
+
+    @Value("${ovsx.cors.allowedMethods:GET,POST,PUT,DELETE,OPTIONS}")
+    String corsAllowedMethods;
+
+    private final LdapConfig ldapConfig;
+    private final LdapUserService ldapUserService;
+    private final org.eclipse.openvsx.UserService userService;
+    private final org.springframework.ldap.core.LdapTemplate ldapTemplate;
+
+    public SecurityConfig(@Autowired(required = false) LdapConfig ldapConfig, 
+                         @Autowired(required = false) LdapUserService ldapUserService, 
+                         org.eclipse.openvsx.UserService userService, 
+                         @Autowired(required = false) org.springframework.ldap.core.LdapTemplate ldapTemplate) {
+        this.ldapConfig = ldapConfig;
+        this.ldapUserService = ldapUserService;
+        this.userService = userService;
+        this.ldapTemplate = ldapTemplate;
+    }
+
+    @PostConstruct
+    public void logSecurityConfig() {
+        logger.info("SecurityConfig - UserSearchBase: '{}', UserSearchFilter: '{}'", ldapUserSearchBase, ldapUserSearchFilter);
+    }
+
+    @Bean
+    public org.springframework.web.cors.CorsConfigurationSource corsConfigurationSource() {
+        var cors = new org.springframework.web.cors.CorsConfiguration();
+        cors.setAllowedOrigins(java.util.List.of(corsAllowedOrigins.split(",")));
+        cors.setAllowedMethods(java.util.List.of(corsAllowedMethods.split(",")));
+        cors.setAllowedHeaders(java.util.List.of("Content-Type", "Authorization", "X-Requested-With", "Accept", "Origin", "Access-Control-Request-Method", "Access-Control-Request-Headers"));
+        cors.setAllowCredentials(true);
+        var source = new org.springframework.web.cors.UrlBasedCorsConfigurationSource();
+        source.registerCorsConfiguration("/**", cors);
+        return source;
+    }
+
     @Bean
     public SecurityFilterChain filterChain(HttpSecurity http, OAuth2UserServices userServices) throws Exception {
         var filterChain = http.authorizeHttpRequests(
                 registry -> registry
-                        .requestMatchers(pathMatchers("/*", "/login/**", "/oauth2/**", "/login-providers", "/user", "/user/auth-error", "/logout", "/actuator/health/**", "/actuator/metrics", "/actuator/metrics/**", "/actuator/prometheus", "/v3/api-docs/**", "/swagger-resources/**", "/swagger-ui/**", "/webjars/**"))
+                        .requestMatchers(toMatchers("/*", "/login/**", "/oauth2/**", "/login-providers", "/user", "/user/auth-error", "/user/csrf", "/logout", "/actuator/health/**", "/actuator/metrics", "/actuator/metrics/**", "/actuator/prometheus", "/v3/api-docs/**", "/swagger-resources/**", "/swagger-ui/**", "/webjars/**"))
                             .permitAll()
-                        .requestMatchers(pathMatchers("/api/*/*/review", "/api/*/*/review/delete", "/api/user/publish", "/api/user/namespace/create"))
+                        .requestMatchers(toMatchers("/api/*/*/review", "/api/*/*/review/delete", "/api/user/publish", "/api/user/namespace/create"))
                             .authenticated()
-                        .requestMatchers(pathMatchers("/api/**", "/vscode/**", "/documents/**", "/admin/api/**", "/admin/report"))
+                        .requestMatchers(toMatchers("/api/**", "/vscode/**", "/documents/**", "/admin/api/**", "/admin/report"))
                             .permitAll()
-                        .requestMatchers(pathMatchers("/admin/**"))
+                        .requestMatchers(toMatchers("/admin/**", "/ldap-test"))
                             .hasAuthority("ROLE_ADMIN")
-                        .requestMatchers(pathMatchers(frontendRoutes))
+                        .requestMatchers(toMatchers(frontendRoutes))
                             .permitAll()
                         .anyRequest()
                             .authenticated()
                 )
-                .cors(configurer -> configurer.configure(http))
-                .csrf(configurer -> configurer.ignoringRequestMatchers(pathMatchers("/api/-/publish", "/api/-/namespace/create", "/api/-/query", "/vscode/**", "/admin/api/**")))
+                .cors(org.springframework.security.config.Customizer.withDefaults())
+                .csrf(configurer -> configurer.disable())
                 .exceptionHandling(configurer -> configurer.authenticationEntryPoint(new Http403ForbiddenEntryPoint()));
 
+        if (ldapConfig != null && ldapConfig.isLdapEnabled()) {
+            configureLdapAuth(filterChain);
+        }
         if (userServices.canLogin()) {
-            var redirectUrl = StringUtils.isEmpty(webuiUrl) ? "/" : webuiUrl;
-            filterChain.oauth2Login(configurer -> {
+            configureOAuth2(filterChain, userServices);
+        }
+
+        return filterChain.build();
+    }
+
+    private void configureLdapAuth(HttpSecurity http) throws Exception {
+        if (ldapTemplate == null || ldapUserService == null) {
+            logger.warn("LDAP dependencies not available, skipping LDAP authentication configuration");
+            return;
+        }
+        
+        String redirectUrl = getRedirectUrl();
+        http.formLogin(configurer -> {
+            configurer.loginPage("/login")
+                    .loginProcessingUrl("/login")
+                    .usernameParameter("username")
+                    .passwordParameter("password")
+                    .successHandler(new LdapAuthenticationSuccessHandler(redirectUrl, userService, ldapTemplate, ldapUserSearchBase, ldapGroupSearchBase, ldapGroupSearchFilter, ldapAdminGroups, ldapBase))
+                    .failureHandler((request, response, exception) -> {
+                        logger.error("LDAP Authentication Failed: " + exception.getMessage());
+                        response.setContentType("application/json");
+                        response.setStatus(401);
+                        response.getWriter().write("{\"error\":\"Invalid username or password\"}");
+                    })
+                    .permitAll();
+        });
+        try {
+            http.authenticationProvider(ldapAuthenticationProvider());
+        } catch (Exception e) {
+            logger.error("LDAP provider not available, skipping LDAP configuration: {}", e.getMessage());
+        }
+    }
+
+    private void configureOAuth2(HttpSecurity http, OAuth2UserServices userServices) throws Exception {
+        String redirectUrl = getRedirectUrl();
+        http.oauth2Login(configurer -> {
             configurer.defaultSuccessUrl(redirectUrl);
             configurer.successHandler(new CustomAuthenticationSuccessHandler(redirectUrl));
             configurer.failureUrl(redirectUrl + "?auth-error");
             configurer.userInfoEndpoint(customizer -> customizer.oidcUserService(userServices.getOidc()).userService(userServices.getOauth2()));
         })
         .logout(configurer -> configurer.logoutSuccessUrl(redirectUrl));
     }
 
-        return filterChain.build();
+    @Bean
+    @ConditionalOnProperty(name = "ovsx.ldap.url", matchIfMissing = false)
+    public LdapAuthenticationProvider ldapAuthenticationProvider() {
+        try {
+            logger.info("Creating LDAP authentication provider with userSearchBase: '{}', userSearchFilter: '{}'", ldapUserSearchBase, ldapUserSearchFilter);
+            
+            var contextSource = ldapConfig.contextSource();
+            var authenticator = new BindAuthenticator(contextSource);
+            
+            if (ldapUserSearchBase != null && !ldapUserSearchBase.isEmpty()) {
+                var userSearch = new FilterBasedLdapUserSearch(ldapUserSearchBase, ldapUserSearchFilter, contextSource);
+                authenticator.setUserSearch(userSearch);
+                logger.info("LDAP user search configured: base='{}', filter='{}'", ldapUserSearchBase, ldapUserSearchFilter);
+            } else {
+                logger.warn("LDAP userSearchBase is empty, using DN patterns instead");
+                authenticator.setUserDnPatterns(new String[]{"uid={0}," + ldapUserSearchBase});
+            }
+            
+            LdapAuthoritiesPopulator authoritiesPopulator = new LdapAuthoritiesPopulator() {
+                @Override
+                public Collection<? extends GrantedAuthority> getGrantedAuthorities(DirContextOperations userData, String username) {
+                    try {
+                        logger.debug("Loading authorities for LDAP user: {}", username);
+                        UserDetails userDetails = ldapUserService.loadUserByUsername(username);
+                        return userDetails.getAuthorities();
+                    } catch (Exception e) {
+                        logger.warn("Failed to load authorities for user '{}': {}", username, e.getMessage());
+                        return java.util.Collections.emptyList();
+                    }
+                }
+            };
+            
+            var provider = new LdapAuthenticationProvider(authenticator, authoritiesPopulator);
+            
+            // Enable strict password comparison to prevent partial password acceptance
+            provider.setUseAuthenticationRequestCredentials(true);
+            
+            logger.info("LDAP authentication provider created successfully with strict password validation");
+            return provider;
+        } catch (Exception e) {
+            logger.error("Failed to create LDAP authentication provider: {}", e.getMessage(), e);
+            throw e;
+        }
     }
 
-    private RequestMatcher[] pathMatchers(String... patterns)
-    {
-        var pathMatchers = new RequestMatcher[patterns.length];
-        for(var i = 0; i < patterns.length; i++) {
-            pathMatchers[i] = PathPatternRequestMatcher.withDefaults().matcher(patterns[i]);
+    private RequestMatcher[] toMatchers(String... patterns) {
+        return java.util.Arrays.stream(patterns)
+            .map(PathPatternRequestMatcher.withDefaults()::matcher)
+            .toArray(RequestMatcher[]::new);
     }
 
-        return pathMatchers;
+    private String getRedirectUrl() {
+        return org.apache.commons.lang3.StringUtils.defaultIfEmpty(webuiUrl, "http://localhost:3000/");
     }
 }
diff --git src://server/src/main/java/org/eclipse/openvsx/security/SessionConfig.java dst://server/src/main/java/org/eclipse/openvsx/security/SessionConfig.java
new file mode 100644
index 00000000..972ede73
--- /dev/null
+++ dst://server/src/main/java/org/eclipse/openvsx/security/SessionConfig.java
@@ -0,0 +1,24 @@
+/********************************************************************************
+ * Copyright (c) 2024 Eclipse Foundation and others
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License v. 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ ********************************************************************************/
+package org.eclipse.openvsx.security;
+
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.session.web.http.CookieHttpSessionIdResolver;
+import org.springframework.session.web.http.HttpSessionIdResolver;
+
+@Configuration
+public class SessionConfig {
+
+    @Bean
+    public HttpSessionIdResolver httpSessionIdResolver() {
+        return new CookieHttpSessionIdResolver();
+    }
+}
\ No newline at end of file
diff --git src://server/src/main/java/org/eclipse/openvsx/security/UserAttributesMapper.java dst://server/src/main/java/org/eclipse/openvsx/security/UserAttributesMapper.java
new file mode 100644
index 00000000..a3c5a611
--- /dev/null
+++ dst://server/src/main/java/org/eclipse/openvsx/security/UserAttributesMapper.java
@@ -0,0 +1,96 @@
+/********************************************************************************
+ * Copyright (c) 2025 Eclipse Foundation and others
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License v. 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ ********************************************************************************/
+package org.eclipse.openvsx.security;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.springframework.ldap.core.LdapTemplate;
+import org.springframework.ldap.core.AttributesMapper;
+
+import javax.naming.directory.SearchControls;
+import javax.naming.directory.Attributes;
+import java.util.Optional;
+
+public class UserAttributesMapper {
+    private static final Logger logger = LoggerFactory.getLogger(UserAttributesMapper.class);
+    
+    private final LdapTemplate ldap;
+    private final String base;
+
+    public UserAttributesMapper(LdapTemplate ldap, String base) {
+        this.ldap = ldap;
+        this.base = base;
+    }
+
+    public static class UserAttributes {
+        private final String fullName;
+        private final String email;
+        
+        public UserAttributes(String fullName, String email) {
+            this.fullName = fullName;
+            this.email = email;
+        }
+        
+        public String fullName() { return fullName; }
+        public String email() { return email; }
+    }
+
+    private Optional<String> safeGet(Attributes attrs, String name) {
+        try {
+            var a = attrs.get(name);
+            return (a != null) ? Optional.ofNullable((String) a.get()) : Optional.empty();
+        } catch (Exception e) {
+            return Optional.empty();
+        }
+    }
+
+    private String extractFullName(Attributes attrs, String username) {
+        return safeGet(attrs, "displayName")
+            .filter(s -> !s.isBlank())
+            .or(() -> safeGet(attrs, "givenName")
+                .flatMap(given -> safeGet(attrs, "sn")
+                    .map(sn -> given + " " + sn)))
+            .or(() -> safeGet(attrs, "cn")
+                .filter(cn -> !cn.equals(username)))
+            .orElse(username);
+    }
+
+    public UserAttributes map(String username) {
+        try {
+            var results = ldap.search(
+                base,
+                "(uid=" + username + ")",
+                searchControls(),
+                (AttributesMapper<UserAttributes>) attrs -> {
+                    String fullName = extractFullName(attrs, username);
+                    String email = java.util.stream.Stream.of("mail", "email")
+                        .map(attr -> safeGet(attrs, attr))
+                        .flatMap(Optional::stream)
+                        .findFirst()
+                        .orElse(username + "@company.com");
+                    return new UserAttributes(fullName, email);
+                }
+            );
+            if (!results.isEmpty()) {
+                return results.get(0);
+            }
+        } catch (Exception e) {
+            logger.warn("LDAP attr lookup failed", e);
+        }
+        return new UserAttributes(username, username + "@company.com");
+    }
+
+    private SearchControls searchControls() {
+        var sc = new SearchControls();
+        sc.setSearchScope(SearchControls.SUBTREE_SCOPE);
+        sc.setReturningAttributes(new String[]{"displayName", "givenName", "sn", "cn", "mail", "email"});
+        return sc;
+    }
+}
\ No newline at end of file
diff --git src://server/src/main/java/org/eclipse/openvsx/web/LdapTestController.java dst://server/src/main/java/org/eclipse/openvsx/web/LdapTestController.java
new file mode 100644
index 00000000..9182f015
--- /dev/null
+++ dst://server/src/main/java/org/eclipse/openvsx/web/LdapTestController.java
@@ -0,0 +1,49 @@
+/********************************************************************************
+ * Copyright (c) 2024 Eclipse Foundation and others
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License v. 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ ********************************************************************************/
+package org.eclipse.openvsx.web;
+
+import org.eclipse.openvsx.security.LdapConfig;
+import org.eclipse.openvsx.security.LdapConnectionTest;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
+import org.springframework.web.bind.annotation.GetMapping;
+import org.springframework.web.bind.annotation.RestController;
+
+import java.util.HashMap;
+import java.util.Map;
+
+@RestController
+@ConditionalOnProperty(name = "ovsx.ldap.url", matchIfMissing = false)
+public class LdapTestController {
+
+    private final LdapConfig ldapConfig;
+    private final LdapConnectionTest ldapConnectionTest;
+
+    public LdapTestController(LdapConfig ldapConfig, LdapConnectionTest ldapConnectionTest) {
+        this.ldapConfig = ldapConfig;
+        this.ldapConnectionTest = ldapConnectionTest;
+    }
+
+    @GetMapping("/ldap-test")
+    public Map<String, Object> testLdapConnection() {
+        Map<String, Object> result = new HashMap<>();
+        result.put("ldapEnabled", ldapConfig.isLdapEnabled());
+        
+        if (ldapConfig.isLdapEnabled()) {
+            try {
+                boolean connected = ldapConnectionTest.testConnection();
+                result.put("connectionTest", connected ? "SUCCESS" : "FAILED");
+            } catch (Exception e) {
+                result.put("connectionTest", "ERROR: " + e.getMessage());
+            }
+        }
+        
+        return result;
+    }
+}
\ No newline at end of file
diff --git src://server/src/main/resources/application.yml dst://server/src/main/resources/application.yml
new file mode 100644
index 00000000..f84eb2c7
--- /dev/null
+++ dst://server/src/main/resources/application.yml
@@ -0,0 +1,19 @@
+ovsx:
+  webui:
+    url: http://localhost:8080
+  cors:
+    allowedOrigins: ${OVSX_CORS_ALLOWED_ORIGINS:http://localhost:3000}
+    allowedMethods: ${OVSX_CORS_ALLOWED_METHODS:GET,POST,PUT,DELETE,OPTIONS}
+  publish:
+    allowNamespaceAutoCreation: ${OVSX_ALLOW_NAMESPACE_AUTO_CREATION:true}
+  ldap:
+    url: ${LDAP_URL:}
+    base: ${LDAP_BASE:}
+    userDn: ${LDAP_USER_DN:}
+    password: ${LDAP_PASSWORD:}
+    userSearchBase: ${LDAP_USER_SEARCH_BASE:ou=users}
+    userSearchFilter: ${LDAP_USER_SEARCH_FILTER:(uid={0})}
+    groupSearchBase: ${LDAP_GROUP_SEARCH_BASE:ou=groups}
+    groupSearchFilter: ${LDAP_GROUP_SEARCH_FILTER:(member=uid={0},{1},{2})}
+    adminGroups: ${LDAP_ADMIN_GROUPS:admins,openvsx-admins}
+    fallbackEmailDomain: ${LDAP_FALLBACK_EMAIL_DOMAIN:company.com}
\ No newline at end of file
diff --git src://server/src/test/java/org/eclipse/openvsx/RegistryAPITest.java dst://server/src/test/java/org/eclipse/openvsx/RegistryAPITest.java
index 89aec276..8445996c 100644
--- src://server/src/test/java/org/eclipse/openvsx/RegistryAPITest.java
+++ dst://server/src/test/java/org/eclipse/openvsx/RegistryAPITest.java
@@ -17,20 +17,21 @@ import org.apache.commons.lang3.ArrayUtils;
 import org.eclipse.openvsx.adapter.VSCodeIdService;
 import org.eclipse.openvsx.cache.CacheService;
 import org.eclipse.openvsx.cache.ExtensionJsonCacheKeyGenerator;
 import org.eclipse.openvsx.cache.LatestExtensionVersionCacheKeyGenerator;
 import org.eclipse.openvsx.eclipse.EclipseService;
 import org.eclipse.openvsx.eclipse.TokenService;
 import org.eclipse.openvsx.entities.*;
 import org.eclipse.openvsx.extension_control.ExtensionControlService;
 import org.eclipse.openvsx.json.*;
 import org.eclipse.openvsx.publish.ExtensionVersionIntegrityService;
+import org.eclipse.openvsx.publish.PublishConfig;
 import org.eclipse.openvsx.publish.PublishExtensionVersionHandler;
 import org.eclipse.openvsx.publish.PublishExtensionVersionService;
 import org.eclipse.openvsx.repositories.RepositoryService;
 import org.eclipse.openvsx.search.*;
 import org.eclipse.openvsx.security.OAuth2AttributesConfig;
 import org.eclipse.openvsx.security.OAuth2UserServices;
 import org.eclipse.openvsx.security.SecurityConfig;
 import org.eclipse.openvsx.storage.*;
 import org.eclipse.openvsx.util.TargetPlatform;
 import org.eclipse.openvsx.util.VersionAlias;
@@ -1461,22 +1462,21 @@ class RegistryAPITest {
     }
 
     @Test
     void testPublishUnknownNamespace() throws Exception {
         mockAccessToken();
         var bytes = createExtensionPackage("bar", "1.0.0", null);
         mockMvc.perform(post("/api/-/publish?token={token}", "my_token")
                 .contentType(MediaType.APPLICATION_OCTET_STREAM)
                 .content(bytes))
                 .andExpect(status().isBadRequest())
-                .andExpect(content().json(errorJson("Unknown publisher: foo"
-                        + "\nUse the 'create-namespace' command to create a namespace corresponding to your publisher name.")));
+                .andExpect(content().json(errorJson("Namespace does not exist and auto-creation is not permitted or user lacks permission: foo")));
     }
 
     @Test
     void testPublishVerifiedOwner() throws Exception {
         mockForPublish("owner");
         mockActiveVersion();
         var bytes = createExtensionPackage("bar", "1.0.0", null);
         mockMvc.perform(post("/api/-/publish?token={token}", "my_token")
                 .contentType(MediaType.APPLICATION_OCTET_STREAM)
                 .content(bytes))
@@ -2509,25 +2509,32 @@ class RegistryAPITest {
 
         @Bean
         PublishExtensionVersionHandler publishExtensionVersionHandler(
                 PublishExtensionVersionService service,
                 ExtensionVersionIntegrityService integrityService,
                 EntityManager entityManager,
                 RepositoryService repositories,
                 JobRequestScheduler scheduler,
                 UserService users,
                 ExtensionValidator validator,
-                ExtensionControlService extensionControl
+                ExtensionControlService extensionControl,
+                PublishConfig config
         ) {
             return new PublishExtensionVersionHandler(
                     service,
                     integrityService,
                     entityManager,
                     repositories,
                     scheduler,
                     users,
                     validator,
-                    extensionControl
+                    extensionControl,
+                    config
             );
         }
+
+        @Bean
+        PublishConfig publishConfig() {
+            return new PublishConfig();
+        }
     }
 }
diff --git src://server/src/test/java/org/eclipse/openvsx/TestSearchConfig.java dst://server/src/test/java/org/eclipse/openvsx/TestSearchConfig.java
index aec136ee..6180227d 100644
--- src://server/src/test/java/org/eclipse/openvsx/TestSearchConfig.java
+++ dst://server/src/test/java/org/eclipse/openvsx/TestSearchConfig.java
@@ -2,30 +2,33 @@
  * Copyright (c) 2020 TypeFox and others
  *
  * This program and the accompanying materials are made available under the
  * terms of the Eclipse Public License v. 2.0 which is available at
  * http://www.eclipse.org/legal/epl-2.0.
  *
  * SPDX-License-Identifier: EPL-2.0
  ********************************************************************************/
 package org.eclipse.openvsx;
 
+import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
 import org.springframework.context.annotation.Profile;
-import org.springframework.data.elasticsearch.client.ClientConfiguration;
-import org.springframework.data.elasticsearch.client.elc.ElasticsearchConfiguration;
-import org.testcontainers.elasticsearch.ElasticsearchContainer;
+import org.springframework.data.elasticsearch.core.ElasticsearchOperations;
+import org.springframework.data.elasticsearch.core.IndexOperations;
+import org.mockito.Mockito;
 
 @Configuration
 @Profile("test")
-public class TestSearchConfig extends ElasticsearchConfiguration {
+public class TestSearchConfig {
 
-    @Override
-    public ClientConfiguration clientConfiguration() {
-        var container = new ElasticsearchContainer("docker.elastic.co/elasticsearch/elasticsearch:8.7.1")
-                .withEnv("discovery.type", "single-node")
-                .withEnv("xpack.security.enabled", "false");
+    @Bean
+    public ElasticsearchOperations elasticsearchOperations() {
+        ElasticsearchOperations mock = Mockito.mock(ElasticsearchOperations.class);
+        IndexOperations indexOps = Mockito.mock(IndexOperations.class);
         
-        container.start();
-        return ClientConfiguration.create(container.getHttpHostAddress());
+        Mockito.when(mock.indexOps(Mockito.any(Class.class))).thenReturn(indexOps);
+        Mockito.when(indexOps.exists()).thenReturn(false);
+        Mockito.when(indexOps.create()).thenReturn(true);
+        
+        return mock;
     }
 }
\ No newline at end of file
diff --git src://server/src/test/java/org/eclipse/openvsx/UserAPITest.java dst://server/src/test/java/org/eclipse/openvsx/UserAPITest.java
index 70b40044..b477fb42 100644
--- src://server/src/test/java/org/eclipse/openvsx/UserAPITest.java
+++ dst://server/src/test/java/org/eclipse/openvsx/UserAPITest.java
@@ -16,20 +16,21 @@ import jakarta.persistence.EntityManager;
 import org.eclipse.openvsx.cache.CacheService;
 import org.eclipse.openvsx.cache.LatestExtensionVersionCacheKeyGenerator;
 import org.eclipse.openvsx.eclipse.EclipseService;
 import org.eclipse.openvsx.eclipse.TokenService;
 import org.eclipse.openvsx.entities.Namespace;
 import org.eclipse.openvsx.entities.NamespaceMembership;
 import org.eclipse.openvsx.entities.PersonalAccessToken;
 import org.eclipse.openvsx.entities.UserData;
 import org.eclipse.openvsx.json.*;
 import org.eclipse.openvsx.repositories.RepositoryService;
+import org.eclipse.openvsx.security.LdapConfig;
 import org.eclipse.openvsx.security.OAuth2AttributesConfig;
 import org.eclipse.openvsx.security.OAuth2UserServices;
 import org.eclipse.openvsx.security.SecurityConfig;
 import org.eclipse.openvsx.storage.StorageUtilService;
 import org.junit.jupiter.api.Test;
 import org.mockito.Mockito;
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.boot.test.autoconfigure.web.client.AutoConfigureWebClient;
 import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
 import org.springframework.boot.test.context.TestConfiguration;
@@ -581,12 +582,17 @@ class UserAPITest {
                 EntityManager entityManager,
                 ClientRegistrationRepository clientRegistrationRepository
         ) {
             return new TokenService(transactions, entityManager, clientRegistrationRepository);
         }
 
         @Bean
         LatestExtensionVersionCacheKeyGenerator latestExtensionVersionCacheKeyGenerator() {
             return new LatestExtensionVersionCacheKeyGenerator();
         }
+
+        @Bean
+        LdapConfig ldapConfig() {
+            return Mockito.mock(LdapConfig.class);
+        }
     }
 }
\ No newline at end of file
diff --git src://server/src/test/java/org/eclipse/openvsx/cache/CacheServiceTest.java dst://server/src/test/java/org/eclipse/openvsx/cache/CacheServiceTest.java
index e6d75e41..a2772719 100644
--- src://server/src/test/java/org/eclipse/openvsx/cache/CacheServiceTest.java
+++ dst://server/src/test/java/org/eclipse/openvsx/cache/CacheServiceTest.java
@@ -133,28 +133,30 @@ class CacheServiceTest {
             var cacheKey = new ExtensionJsonCacheKeyGenerator().generate(namespace.getName(), extension.getName(),
                     extVersion.getTargetPlatform(), extVersion.getVersion());
 
             var json = registry.getExtension(namespace.getName(), extension.getName(), extVersion.getTargetPlatform(), extVersion.getVersion());
             assertEquals(Long.valueOf(0), json.getReviewCount());
             assertNull(json.getAverageRating());
 
             var poster = new UserData();
             poster.setLoginName("user1");
             entityManager.persist(poster);
+            entityManager.flush();
             setLoggedInUser(poster);
 
             var review = new ReviewJson();
             review.setRating(3);
             review.setComment("Somewhat ok");
             review.setTimestamp("2000-01-01T10:00Z");
 
             registry.postReview(review, namespace.getName(), extension.getName());
+            entityManager.flush();
             assertNull(cache.getCache(CACHE_EXTENSION_JSON).get(cacheKey, ExtensionJson.class));
 
             json = registry.getExtension(namespace.getName(), extension.getName(), extVersion.getTargetPlatform(), extVersion.getVersion());
             assertEquals(Long.valueOf(1), json.getReviewCount());
             assertEquals(Double.valueOf(3), json.getAverageRating());
 
             var cachedJson = cache.getCache(CACHE_EXTENSION_JSON).get(cacheKey, ExtensionJson.class);
             assertEquals(json, cachedJson);
         }
     }
@@ -166,33 +168,36 @@ class CacheServiceTest {
         try (var tempFile = insertExtensionVersion()) {
             var extVersion = tempFile.getResource().getExtension();
             var extension = extVersion.getExtension();
             var namespace = extension.getNamespace();
             var cacheKey = new ExtensionJsonCacheKeyGenerator().generate(namespace.getName(), extension.getName(),
                     extVersion.getTargetPlatform(), extVersion.getVersion());
 
             var poster = new UserData();
             poster.setLoginName("user1");
             entityManager.persist(poster);
+            entityManager.flush();
             setLoggedInUser(poster);
 
             var review = new ReviewJson();
             review.setRating(3);
             review.setComment("Somewhat ok");
             review.setTimestamp("2000-01-01T10:00Z");
 
             registry.postReview(review, namespace.getName(), extension.getName());
+            entityManager.flush();
             var json = registry.getExtension(namespace.getName(), extension.getName(), extVersion.getTargetPlatform(), extVersion.getVersion());
             assertEquals(Long.valueOf(1), json.getReviewCount());
             assertEquals(Double.valueOf(3), json.getAverageRating());
 
             registry.deleteReview(namespace.getName(), extension.getName());
+            entityManager.flush();
             assertNull(cache.getCache(CACHE_EXTENSION_JSON).get(cacheKey, ExtensionJson.class));
 
             json = registry.getExtension(namespace.getName(), extension.getName(), extVersion.getTargetPlatform(), extVersion.getVersion());
             assertEquals(Long.valueOf(0), json.getReviewCount());
             assertNull(json.getAverageRating());
 
             var cachedJson = cache.getCache(CACHE_EXTENSION_JSON).get(cacheKey, ExtensionJson.class);
             assertEquals(json, cachedJson);
         }
     }
@@ -224,26 +229,28 @@ class CacheServiceTest {
         try (var tempFile = insertExtensionVersion()) {
             var extVersion = tempFile.getResource().getExtension();
             var extension = extVersion.getExtension();
             var namespace = extension.getNamespace();
             var cacheKey = new ExtensionJsonCacheKeyGenerator().generate(namespace.getName(), extension.getName(),
                     extVersion.getTargetPlatform(), extVersion.getVersion());
 
             var newVersion = "0.2.0";
             var oldVersion = extVersion.getVersion();
             try (var newTempFile = insertNewVersion(extension, extVersion.getPublishedWith(), newVersion)) {
+                entityManager.flush();
 
                 var json = registry.getExtension(namespace.getName(), extension.getName(), extVersion.getTargetPlatform(), newVersion);
                 assertTrue(json.getAllVersions().containsKey(newVersion));
                 assertTrue(json.getAllVersions().containsKey(oldVersion));
 
                 admins.deleteExtension(namespace.getName(), extension.getName(), extVersion.getTargetPlatform(), newVersion, admin);
+                entityManager.flush();
                 assertNull(cache.getCache(CACHE_EXTENSION_JSON).get(cacheKey, ExtensionJson.class));
 
                 json = registry.getExtension(namespace.getName(), extension.getName(), extVersion.getTargetPlatform(), extVersion.getVersion());
                 assertFalse(json.getAllVersions().containsKey(newVersion));
                 assertTrue(json.getAllVersions().containsKey(oldVersion));
 
                 var cachedJson = cache.getCache(CACHE_EXTENSION_JSON).get(cacheKey, ExtensionJson.class);
                 assertEquals(json, cachedJson);
             }
         }
@@ -259,21 +266,23 @@ class CacheServiceTest {
             var namespace = extension.getNamespace();
             var cacheKey = new ExtensionJsonCacheKeyGenerator().generate(namespace.getName(), extension.getName(),
                     extVersion.getTargetPlatform(), extVersion.getVersion());
 
             registry.getExtension(namespace.getName(), extension.getName(), extVersion.getTargetPlatform(), extVersion.getVersion());
 
             var newVersion = "0.2.0";
             var oldVersion = extVersion.getVersion();
             try (var newTempFile = insertNewVersion(extension, extVersion.getPublishedWith(), newVersion)) {
                 newTempFile.getResource().getExtension().setPreRelease(true);
+                entityManager.flush();
                 extensions.updateExtension(extension);
+                entityManager.flush();
                 assertNull(cache.getCache(CACHE_EXTENSION_JSON).get(cacheKey, ExtensionJson.class));
 
                 var json = registry.getExtension(namespace.getName(), extension.getName(), extVersion.getTargetPlatform(), oldVersion);
                 assertTrue(json.getAllVersions().containsKey(oldVersion));
                 assertTrue(json.getAllVersions().containsKey(newVersion));
                 assertTrue(json.getAllVersions().containsKey("latest"));
                 assertTrue(json.getAllVersions().containsKey("pre-release"));
 
                 var cachedJson = cache.getCache(CACHE_EXTENSION_JSON).get(cacheKey, ExtensionJson.class);
                 assertEquals(json, cachedJson);
diff --git src://server/src/test/resources/application.yml dst://server/src/test/resources/application.yml
index d5a207a0..15a978b6 100644
--- src://server/src/test/resources/application.yml
+++ dst://server/src/test/resources/application.yml
@@ -37,10 +37,14 @@ org:
       type: sql
     miscellaneous:
       allow-anonymous-data-usage: false
 
 ovsx:
   redis:
     embedded: true
   storage:
     local:
       directory: /tmp
+  elasticsearch:
+    enabled: false
+  databasesearch:
+    enabled: true
diff --git src://webui/src/components/LdapLoginForm.tsx dst://webui/src/components/LdapLoginForm.tsx
new file mode 100644
index 00000000..900dfa08
--- /dev/null
+++ dst://webui/src/components/LdapLoginForm.tsx
@@ -0,0 +1,80 @@
+/** ******************************************************************************
+ * Copyright (c) 2025 Precies. Software OU and others
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License v. 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ * ****************************************************************************** */
+import React, { useState } from 'react';
+import { Box, Button, Stack, TextField } from '@mui/material';
+
+interface Props {
+    csrfToken: string;
+    onSuccess: () => void;
+}
+
+export const LdapLoginForm: React.FC<Props> = ({ csrfToken, onSuccess }) => {
+    const [username, setUsername] = useState('');
+    const [password, setPassword] = useState('');
+    const [error, setError] = useState('');
+
+    const handleSubmit = async (e: React.FormEvent) => {
+        e.preventDefault();
+        setError('');
+        const formData = new FormData();
+        formData.append('username', username);
+        formData.append('password', password);
+
+        try {
+            const url = window.location.origin;
+            const res = await fetch(`${url}/login`, {
+                method: 'POST',
+                credentials: 'include',
+                body: formData,
+            });
+            const payload = await res.json().catch(() => {
+                throw new Error('Invalid JSON');
+            });
+            if (!res.ok || !payload.success) {
+                throw new Error(payload.error || 'Login failed');
+            }
+            onSuccess();
+        } catch (err: any) {
+            console.error('LDAP login error:', err);
+            // Map technical errors to generic user-facing messages
+            let userMessage = 'Login failed. Please check your credentials and try again.';
+            if (err?.response?.status === 401) {
+                userMessage = 'Invalid username or password.';
+            }
+            setError(userMessage);
+        }
+    };
+
+    return (
+        <Box component='form' onSubmit={handleSubmit}>
+            <Stack spacing={2}>
+                {error && <div style={{ color: 'red' }}>{error}</div>}
+                <TextField
+                    fullWidth
+                    label='Username'
+                    value={username}
+                    onChange={e => setUsername(e.target.value)}
+                    required
+                />
+                <TextField
+                    fullWidth
+                    label='Password'
+                    type='password'
+                    value={password}
+                    onChange={e => setPassword(e.target.value)}
+                    required
+                />
+                <Button type='submit' fullWidth variant='contained'>
+                    Login with LDAP
+                </Button>
+            </Stack>
+        </Box>
+    );
+};
\ No newline at end of file
diff --git src://webui/src/default/login.tsx dst://webui/src/default/login.tsx
index ae647ce7..b7983bbd 100644
--- src://webui/src/default/login.tsx
+++ dst://webui/src/default/login.tsx
@@ -1,43 +1,61 @@
 /** ******************************************************************************
  * Copyright (c) 2025 Precies. Software OU and others
  *
  * This program and the accompanying materials are made available under the
  * terms of the Eclipse Public License v. 2.0 which is available at
  * http://www.eclipse.org/legal/epl-2.0.
  *
  * SPDX-License-Identifier: EPL-2.0
  * ****************************************************************************** */
-import React, { FunctionComponent, ReactNode, useState } from "react";
-import { Button, Dialog, DialogContent, DialogTitle, Stack } from "@mui/material";
+import React, { FunctionComponent, ReactNode, useState } from 'react';
+import { Button, Dialog, DialogContent, DialogTitle, Stack } from '@mui/material';
+import { useCsrfToken } from '../hooks/useCsrfToken';
+import { LdapLoginForm } from '../components/LdapLoginForm';
 
-export const LoginComponent: FunctionComponent<LoginComponentProps> = (props) => {
-    const [dialogOpen, setDialogOpen] = useState(false);
+export const LoginComponent: FunctionComponent<LoginComponentProps> = ({ loginProviders, renderButton }) => {
+    const [open, setOpen] = useState(false);
+    useCsrfToken(); // Keep for compatibility
 
-    const showLoginDialog = () => setDialogOpen(true);
+    const providers = Object.keys(loginProviders);
+    const hasLdap = providers.indexOf('ldap') !== -1;
+    const oauth = providers.filter(p => p !== 'ldap');
 
-    const providers = Object.keys(props.loginProviders);
-    if (providers.length === 1) {
-        return props.renderButton(props.loginProviders[providers[0]]);
-    } else {
-        return <>
-            {props.renderButton(undefined, showLoginDialog)}
-            <Dialog
-                fullWidth
-                open={dialogOpen}
-                onClose={() => setDialogOpen(false)}
-            >
+    if (providers.length === 1 && !hasLdap) {
+        return renderButton(loginProviders[providers[0]]);
+    }
+
+    const onSuccess = () => {
+        setOpen(false);
+        window.location.reload();
+    };
+
+    return (
+        <>
+            {renderButton(undefined, () => setOpen(true))}
+            <Dialog open={open} onClose={() => setOpen(false)} fullWidth>
                 <DialogTitle>Log In</DialogTitle>
                 <DialogContent>
                     <Stack spacing={2}>
-                        {providers.map((provider) => (<Button key={provider} fullWidth variant='contained' color='secondary' href={props.loginProviders[provider]}>{provider}</Button>))}
+
+                        {hasLdap && (
+                            <LdapLoginForm
+                                csrfToken=""
+                                onSuccess={onSuccess}
+                            />
+                        )}
+                        {oauth.map(p => (
+                            <Button key={p} href={loginProviders[p]} fullWidth variant='contained'>
+                                Login with {p}
+                            </Button>
+                        ))}
                     </Stack>
                 </DialogContent>
             </Dialog>
-        </>;
-    }
+        </>
+    );
 };
 
 export interface LoginComponentProps {
     loginProviders: Record<string, string>
     renderButton: (href?: string, onClick?: () => void) => ReactNode
 }
\ No newline at end of file
diff --git src://webui/src/hooks/useCsrfToken.ts dst://webui/src/hooks/useCsrfToken.ts
new file mode 100644
index 00000000..b5798012
--- /dev/null
+++ dst://webui/src/hooks/useCsrfToken.ts
@@ -0,0 +1,13 @@
+/** ******************************************************************************
+ * Copyright (c) 2025 Precies. Software OU and others
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License v. 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ * ****************************************************************************** */
+
+export function useCsrfToken() {
+    return { token: '', loading: false, error: '' };
+}
\ No newline at end of file
